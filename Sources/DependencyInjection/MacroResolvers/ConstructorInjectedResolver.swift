//
//  ConstructorInjectedResolver.swift
//  DependencyInjection
//
//  Created by Tyler Thompson on 7/29/25.
//

/// The backing resolver for the ``ConstructorInjected(_:)-swift.macro`` macro.
///
/// You do not create this type directly. It is generated by the `@ConstructorInjected` macro expansion.
/// The dependency is resolved immediately at initialization time and stored for the
/// lifetime of the owning object.
///
/// For async factories, a `Task` is created at init and cancelled in `deinit`.
public final class ConstructorInjectedResolver<Value, Factory: Sendable>: @unchecked Sendable {
    /// The resolved dependency value, set once at init.
    public let wrappedValue: Value
    let factory: Factory
    let cleanup: () -> Void
    public init(_ factory: SyncFactory<Value>, file: String = #file, line: UInt = #line, function: String = #function) where Factory == SyncFactory<Value> {
        wrappedValue = factory(file: file, line: line, function: function)
        self.factory = factory
        cleanup = { }
    }

    public init<D>(_ factory: Factory, file: String = #file, line: UInt = #line, function: String = #function) where Factory == SyncThrowingFactory<D>, Value == Result<D, any Error> {
        wrappedValue = Result { try factory(file: file, line: line, function: function) }
        self.factory = factory
        cleanup = { }
    }

    public init<D>(_ factory: Factory, file: String = #file, line: UInt = #line, function: String = #function) where Factory == AsyncFactory<D>, Value == Task<D, Never> {
        let task = Task { await factory(file: file, line: line, function: function) }
        wrappedValue = task
        self.factory = factory
        cleanup = task.cancel
    }

    public init<D>(_ factory: Factory, file: String = #file, line: UInt = #line, function: String = #function) where Factory == AsyncThrowingFactory<D>, Value == Task<D, any Error> {
        let task = Task { try await factory(file: file, line: line, function: function) }
        wrappedValue = task
        self.factory = factory
        cleanup = task.cancel
    }

    deinit {
        cleanup()
    }

    /// The underlying factory, accessible via the `$` prefix on the annotated property.
    public var projectedValue: Factory {
        factory
    }
}
